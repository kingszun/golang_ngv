박문석 - itstudy@kakao.com

# 수업 자료
- ppt 나 pdf : http://ggangpae1.tistory.com/561

# 환경
- go 1.20
- IDE : Visual Studio Code

# Go 프로그램을 실행하기 위한 조건
- main 함수를 가진 main 패키지가 있어야 합니다.

# 실행 방법
## 인터프리터 방식으로 실행 : 임시 실행 파일을 만들어서 실행, 학습을 할 때 주로 이용
``` bash 
go run /path/to/실행파일
```

## 바이너리 파일을 만들어서 실행 : 배포할 때 사용
- 1.16 버전 이상은 아래 명령어를 사용하고자 하는 경우에 모듈을 생성해야 합니다.
- 모듈 생성 명령
    ``` bash 
    go mod init <모듈이름> #디렉토리 이름이나 배포할 패키지 이름으로 생성
    ```
- 모듈 빌드
    ``` bash
    go build # 모듈 이름의 바이너리 파일 생성
    go build -o <binary_name>
    ```
- 실행은 바이너리파일 경로를 입력하면 됩니다.

#
- 전역으로 사용할 경우 반드시 예약어가 붙어야함
- go는 2path 컴파일 사용
  1. 전역 예약어 확인
  2. 중괄호 확인

# Import
- 가져오겠다는 의미
- ```import "fmt"``` 사용시 가져와서 사용하겠다는 의미
- 가져와서 사용하지 않으면 컴파일 되지 않음
- ```import <name> "fmt"``` fmt라는 이름을변경하여 사용
  - "go"에는 별명이 존재하지 않는다.
  - ```import . "fmt"``` 하면 fmt 이름사용x

# main - Entry Point(시작하는 함수)
하나의 모듈에는 하나의 main만 존재해야 함
- ```go run```으로 실행할때는 상관 없음
``` go
package main
func main(){

}
```

# 크로스 컴파일
- go 나 c/c++의 가장 큰 단점은 플랫폼(OS, 디바이스) 종속적이다.
  - 운영체제별로 실행 파일이 다르게 만들어져야 한다.
  - go 나 c/c++은 직접 실행하기 때문
  - go는 다른 플랫폼 실행 파일을 만들 수 있는 명령어를 제공
  - ```GOOS=<운영체제이름> GOARCH=<CPU 종류> go build``` 옵션 사용해서 빌드

#기본 문법
## 기본 규칙
### ;
- 표현식(한 번에 수행되는 문장)의 끝에 사용이 가능하지만 생략 가능
- 하나의 라인에 2개의 표현식이 있는 경우는 구분을 위해서는 작성
- ```for```문 작성할때만 사용됨

### 주석
- 한줄 주석 : //
- 블럭 주석 : /* */

### 들여쓰기
- 탭을 이용
- gofmt 소스파일경로 를 이용해서 내용을 정렬하는 것이 가능(VS Code 와 같은 IDE를 사
용하면 자동 수행)

사용하지 않는 변수를 선언하거나 사용하지 않는 패키지를 import 하면 에러가 발생 u? 코드가 한 문장이거나 아예 존재하지 않더라도 코드 블록은 중 괄호로 감싸야 함
Go의 함수는 값을 여러 개 반환할 수. 있음
암시적(묵시적) 형 변환이 없음 ? 명시적(강제) 형 변환 만 존재

## 패키지
- Go 프로그램은 한 개 이상의 패키지로 구성
- 패키지는 한 개 이상의 Go 소스 파일을 포함하는 디렉토리이며 모든 Go 파일은 패키지에 속 함
- package 키워드를 이용해 정의할 수 있는데 다른 애플리케이션이나 패키지에 공유될 패키지 라면 마음대로 패키지의 이름을 정할 수 - 있지만 실행 가능한 애플리케이션을 만들려고 한다면 패키지 이름은 main이 되어야 함
- import 키워드는 작성하고자 하는 Go 프로그램에 다른 Go 패키지의 기능을 사용하고자 할 때 사용
- 패키지 이름은 Go 파일의 최 상단에 선언 
  - ```package mypackage```
  - 해당 Go 파일은 mypackage 라는 패키지에 속함
  - Go 언어에서 패키지 이름은 일반적으로 소문자로 선언하고 패키지의 디렉토리 이름은
- 패키지 이름과 동일하게 지정하는 것을 권장
- Go 패키지는 Go 표준 라이브러리가 될 수도 있고 외부에서 가져온 패키지일 수도 있는데 Go 표준 라이브러리의 패키지들은 패키지의 - 외부 호스트 이름이나 주소 없이 이름(os. fmt)을 이 용해 import할 수 있는 반면 외부 패키지들은 github.com/spfl3/cobra와 같이 URL을 사용해서 import

# 자료형
데이터를 어느 정도 크기의 메모리에 저장하고 어떻게 읽고 쓰기를 할 지에 대한 내용
- Value Type - Reference Type
  - 내가 만든 변수를 같이 쓰고싶은데 바꾸면 안될경우 value Type 기본개념 복사
  - 내가 만든 변수를 바꿀수 있도록 하려면 Reference Type
  - Value Type : 메모리의 값을 저장하는 자료형
  - Reference Type : 데이터가 저장된 곳의 참조를 저장하는 자료형
    - slice
    - map
    - pointer
- scala Data - Vector Type
  - Scala Data : 1개의 데이터
  - Vector Data : 0개 이상의 데이터 모임(collection, 자료구조)
- mutable - immutable
  - mutable(var) : 변경 가능한 데이터
  - imutable(const) : 변경 불가능한 데이터

- 숫자 자료형
  - 정수
    - 부호 있는 정수 : int8(8bit), int16(16bit), int32(32bit), int64(64bit), int(system word의 크기 -> 요즘은 보통 64bit)
    - 부호 없는 정수(양수만 저장) : uint8(8bit), uint16(16bit), uint32(32bit), uint64(64bit), uint(system word의 크기 -> 요즘은 보통 64bit)
    - 일반정수는 기본적으로 int(10 -> int)
    - 정수를 사용할때는 항상 오버플로우, 언더플로우 문제 조심해야함
      - int8의 경우 128을 쓰면 -128이 되어버림 -129를 쓰면 127이 되어버림
    - 만들 때 되도록 바이트 수로 System Word바이트 단위로 묶어서 사용하는 것이 좋음
      - 이경우 128바이트 사용
        ``` go
        var a int8 = 10
        var b int8 = 10
        var c int32 = 10
        ``` 
      - 이경우 192바이트 사용
        ``` go
        var a = int8 = 10
        var b = int32 = 10
        var c = int8 = 10
        ```
  - 실수
    - float32 : 소수 7째자리까지 정밀도 보장
    - float64 : 소수 15째자리까지 정밀도를 보장
    - 소수는 표현의 한계가 있어서 정확한 결과를 만들지 못하기도 함
    - 실수를 배열로 만들어서 문제를 해결하거나 문자열로 변경해서 문제를 해결
    - 머신 엡실론 : 오류의 한계치 - 0.00000000000001(10의 -14승)
  - 복소수
  - ASCII 문자 1개(byte)
    - '영문자 or 숫자 or 특수문자 1개'
    - 문자로 출력하고자 하면 Printf dptj %c로 출력하거나 문자열로 변환해서 출력
    - 파일 입출력 or 네트워크에서 읽고 쓸때 이용
  - UNICODE 문자 1개(rune - uint32 와 동일)
    - '모든 문자'
    - 문자로 출력하고자 하면 Printf dptj %c로 출력하거나 문자열로 변환해서 출력
    - 파일 입출력 or 네트워크에서 읽고 쓸때 이용

# 문자열
"문자열"을 표현합니다.
변하지 않는 고정된 데이터
이 데이터에 새로운 문자열을 추가하면 이어붙이기가 되는 것이 아니라 일단 원본을 다른 곳에 복사한 후 이어붙이기를 합니다.

# 상수
## 일반 상수
var 대신 const를 붙이면 읽기 전용이 됨
``` go
const name 자료형 = 값
```
## 나열형(열거형) 상수 - enum
``` go
const (
    var1 자료형 = 값 // 첫번째 데이터는 값을 생략 할 수 없음
    var2 자료형 = 값 // 첫번째 데이터부터는 값을 생략할 수 있지만 생략하면 이전값과 동일
    )
```
값을 표현할 때 iota를 이용하면 sequence 를 생성해서 사용할 수 있습니다.
숫자는 0부터 시작
``` go
//동시에 사용할 수 없는 옵션 : 택 일
const (
    a int = 97
    b int = 98
    c int = 99
    ...
)
// 동시에 사용 할 수 있는 옵션 : 다중 선택 가능 - 다중선택 할 때는 + or | 를 이용
const (
    LBUTTONCLICK = 1    //1<<iota (0000 0001)
    RBUTTONCLICK = 2    //1<<iota (0000 0010)
    SHIFT = 4           //1<<iota (0000 0100)
    CONTROL = 8         //1<<iota (0000 1000)
    ..
)
```
Go 에서는 const가 macro와 유사한 역할을 한다.
- Go 에서는 compile될 때 const가 리터럴로 변환이 되어버림
    ``` go
    const a int = 10 
    var b int = 10

    fmt.Println(a) // fmt.Println(10)과 동일
    fmt.Println(b)
    ```

# 연산자
## 대입연산자
- = : 대입연산자 - 오른쪽의 데이터를 왼쪽의 변수에 대입
- := : 대입과 선언을 동시에 수행 - {} 안에서만 사용 가능


Go는 동일한 자료형끼리만 연산이 가능하고 결과는 연산을 수행한 자료형입니다.
다른 자료형끼리 산술 연산을 하면 에러
+는 숫자가 아닌 문자열끼리도 연산 가능

형변환 : 데이터의 자료형을 다른 자료형으로 변환
숫자 자료형끼리 문자열 자료형끼리만 가능
숫자를 문자열로 변경하거나 문자열을 숫자로 변경하는 것은 메서드를 이용해야 함

변경하고자하는자료형(데이터)
메모리 크기가 큰 자료형을 작은 자료형으로 변경하면 오버플로우나 언더플로우가 발생할 수 있고 실수를 정수로 변경하면 소수가 사라집니다.

## 증감연산자 : ++, --
변수의 뒤에 사용이 되서 변수의 값을 1 증가시키거나 1 감소시킵니다.
숫자 자료형 모두에 사용 가능
++ 와 -- 한 연산식은 다른 데이터와 연산을 못합니다.
함수의 매개변수로도 사용 불가능합니다.

## 비교연산자 : >, >=, <, <=
결과가 bool(참과 거짓 - true or false)
- == : 같다
- != : 다르다
  
## 논리연산자 : bool 데이터를 가지고 연산을 수행
- 데이터 or 수식 : 반대로(true->false, false->true)
- 데이터 or 수식 && 데이터 or 수식 : and - 둘다 true인 경우 true
- 데이터 or 수식 || 데이터 or 수식 : or - 둘다 false인 경우 false

- short -circuit
  - && 는 앞의 데이터나 수식이 false인 경우 뒤의 수식을 확인하지 않음
  - || 는 앞의 데이터나 수식이 true인 경우 뒤의 수식을 확인하지 않음

## 비트연산자 : &, |, ^, &^
숫자 데이터를 2진수로 변환해서 비트 단위로 연산한 후 숫자 데이터로 리턴하는 연산자
- & : and - 둘다 1인 경우 1 그 이외의 경우는 0
- | : or - 둘다 0인 경우 0 그 이외의 경우는 1
- ^ : xor(exclusive or) - 같으면 0 다르면 1
- &^ : and not - And의 반대 결과, 둘다 1인 경우 0 그 이외의 경우는 1
  ```
  20 - 0001 0100
  17 - 0001 0001
  20 & 17 -> 0001 0000
  20 | 17 -> 0001 0101
  ```
- "<<" : 왼쪽 shift - 앞에서부터 데이터를 제거하고 뒤에 0을 추가(기본적으로는 2배씩 증가, 음수는 첫번째 밀때는 부호가 변경)
- ">>" : 오른쪽 shift - 뒤에서부터 데이터를 제거하고 맨 앞에 있었던 비트를 앞에 추가

## 복합 대입 연산
연산자= : 왼쪽의 데이터와 오른쪽의 데이터를 연산한 후 왼쪽의 변수에 대입
``` go
var a int = 10
a += 20 // a = a+20
```

## 기타 연산자
- [] : 배열이나 슬라이스, 맵을 만들 때 사용하고, 데이터를 접근할 때 사용
- . : 구조체를 이용해서 멤버에 접근할 때 사용
- &var : 참조
  ``` go
  var a int = 10
  &a // 10이 저장된 곳의 참조
  ```
- *var : 역참조
- ... : 배열을 선언할 때 사용할 수 있고 그 외의 경우는 slice사용
- : : 배열이나 슬라이스에서 범위를 나타낼 때 사용
- <- : 채널에 값을 저장하거나 읽어올 때 사용

## 제어문
Go에서는 if보다 switch사용
대부분의 경우 switch가 if보다 빠름
모든 자료구조중에 map이 제일 빠름(배열, 슬라이스 보다) map 사용에 익숙해지자
1. if
   ```
   if bool 표현식(변수, 수식, 함수호출){
    true 일 때 수행할 내용
   } else if bool 표현식(변수, 수식, 함수 호출){
    앞의 내용이 false이고 자신의 표현식이 true 일 때 수행할 내용
   }...{

   }else{
    앞의 모든 내용이 false 일 때 수행할 내용
   }
   ```
   - 주의점
     - 여는 중괄호({)는 반드시 표현식 과 같은 라인에 작성
     - if 는 한번만 사용 가능
     - else if 는 생략 가능하고 개수 제한 없음
     - else 는 생략 가능하고 1번만 사용 가능
   - go 에서의 특별한 형식

2. switch
   - fallthrough
    ``` go
    switch 표현식{
      case 값:
        표현식의 결과가 값일 때 수행할 내용
        ..
      case ...
      default :
        앞에 case 에 일치하는 값이 없을 때 수행할 내용
    }
    ```
  - case의 개수 재한 없음
  - default 생략 가능
  - fallthrough 가 기본이 아님
  - 아래 문장을 수행하고자 하면 fallthrough를 기재해야함.(요즘나오는 건 거의다 그럼 uml 공부하자)
  - 값을 작성할 때 ```,```로 구분해서 여러 개 값 설정 가능
  - 다른 형식으로 사용 가능(if 대체 가능)
    ``` go
    switch true(생략){
      case 조건:
        조건이 true일 때 수행할 내용
      ..
    }
    ```

  
3. goto
  특정 레이블로 수행을 이동시킴
  - 레이블 생성
    - 레이블이름:
  - goto 레이블이름
4. for
   - break
   - continue
   - for 기본 형식
    ``` go
    for 처음수행되는 문장; 조건식; 조건식이 참이어서 돌아왔을 때 부터 수행되는 문장{
      조건식이 false가 아닌 경우 수행할 문장
      }
    ```
    - 처음 수행되는 문장은 생략이 가능하고 2개 이상의 코드를 수행할 수 있는데, 이 때는 ```,```로 구분
    - 조건식이 참이어서 돌아왔을 때 부터 수행되는 문장은 생략이 가능하고 2개 이상의 코드를 수행할 수 있는데, 이 때는 ```,```로 구분
    - for {} 인 경우는 무한루프
    - 처음 수행되는 문장에서 변수를 생성하면 for 안에서만 사용 가능
  - for를 이용한 순회
    ```
      for 변수 := range 배열이나 슬라이스 또는 Map{
        내용
      }
    ```
    - 배열이나 슬라이스는 인덱스 와 값을 리턴하고 Map은 key와 value를 리턴
    - 사용하지 않을 때는 _로 설정
  - break
    - for 종료
  - continue
    - 아래 문장을 수행하지 않고 다음 반복으로 진행
5. return
   - 함수 or 메소드에서 

# 배열과 슬라이스 및 포인터
## 배열과 슬라이스
### 배열
value Type : = 를 이용해서 다른 곳에 대입하면 데이터 전체를 다른 곳에 복사해서 대입
크기가 고정 : 정적
테이터 개수 : ```len(배열이름)```
go 에서는 포인터를 이용한 연산이 불가능하기 때문에 배열을 포인터로 대체할 수 없음

``` go
var 배열이름 [] 1개의 자료형 = [개수]자료형 // zero value로 초기화
var 배열이름 [개수] 자료형
배열이름 := [개수]자료형{값 나열}
배열이름 := [...]자료형{값을 나열}
// 값을 나열할 때 여러 줄에 입력을 할 때는 마지막에 ,을 추가해야합니다.
{10, 20, 30}
{
  10,
  20,
  30,
}
{
  10,
  20,
  30 // 이렇게쓰면 에러남 마지막에 무조건 , 써줘야함
}
```
데이터 1개 접근 : ```배열이름[인덱스]```
- 인덱스는 0부터 데이터개수 -1 까지
데이터 전체 순회 : 
``` go
for 인덱스, 값 := range 배열이름{
  내용
}
// 이터레이터를 사용하지 않을경우 더 느려짐
// 엥간하면 이터레이터를 사용하자
for i:=0; i<len(배열이름); i++{
  배열이름[i]
}
// 인덱스를 사용하지 않고자 할 때는 _로 작성
for _, 값 := range 배열이름{
  내용
}
// 값을 사용하지 않는 경우에는 인덱스만 작성해도 되고, _로 작성해도 됩니다.
for 인덱스 := range 배열이름{
  내용
}
for 인덱스, _ := range 배열이름{
  내용
}
```

### 슬라이스
Reference Type : =를 이용해서 다른 곳에 대입하면 데이터는 복사하지 않고 참조만 전달
크기가 변경 가능 : 동적, 크기가 변경되는 상황이 발생하면 현재 크기의 2배 크기로 늘어나서 데이터를 복사하고 그 아래 추가
데이터 개수 : ```len(슬라이스이름)```
할당 받은 메모리 크기 : ```cap(슬라이스이름)```
슬라이스는 배열을 가리키는 포인터와 len과 cap으로 구성

- 생성
  ``` go
  var 슬라이스이름 []자료형 // 슬라이스의 참조를 저장할 수 있는 변수를 생성, 현재는 nil
  슬라이스이름 := 배열이나 슬라이스이름[시작인덱스:종료인덱스+1] //기존 배열이나 슬라이스를 이용해서 생성
  슬라이스이름 := 배열이나 슬라이스이름[시작인덱스:종료인덱스+1:용량] //기존 배열이나 슬라이스를 이용해서 생성

  슬라이스이름 := []자료형{값을 나열}
  슬라이스이름 := []자료형{} // 굉장히 안좋은 방식 이건 쓰지말자
  // 슬라이스는 데이터 추가될때마다 용량이 2배씩 증가합니다
  // 10번추가하면 1024배가 됨

  슬라이스이름 := make([] 자료형, 데이터개수) // 초기용량 생략하면 데이터 개수와 동일
  슬라이스이름 := make([] 자료형, 데이터개수, 초기 용량)

  ```
  - 데이터 1개 접근이나 순회 그리고 데이터 개수를 구하는 방법은 배열과 동일
  - 슬라이스 내부 구조
    - 슬라이스 내부에는 배열에 대한 참조
    - 저장된 데이터 개수를 의미하는 len
    - 할당받은 메모리 개수를 의미하는 cap
  - 배열을 이용해서 만들때는 len이나 cap이 배열의 데이터 개수를 초과할 수는 없습니다.
  - 데이터 추가
    - append(슬라이스이름, 데이터 나열 하거나 슬라이스이름 ...)을 호출해서 돌려받으면 되는데 이 때 여분의 공간이 있으면 별문제가 없지만 여분의 공간이 없으면 새로운 공간을 할당받아서 생성되고 참조도 변경된다.
    - 기존 배열이나 슬라이스와의 연결이 끊어질 수 있습니다.
  - 데이터 삭제
    - 슬라이스의 데이터를 삭제하는 함수는 없음 -> 알고리즘 이용
    - 삭제하고자 하는 데이터를 기준으로 앞과 뒤를 선택해서 합치면 된다.
      ``` go
      append([] interface {}, data interface{} ...) [] interface {}
      ```
      - []: 슬라이스
      - interface {}: 빈 인터페이스, 모든 자료형의 데이터를 대입받는 것이 가능
      - ...: 함수의 매개변수에서 `...`은 데이터 개수에 상관없이 `,`로 구분해서 대입이 가능
        - 단, 내부적으로 슬라이스를 만들기 때문에 슬라이스를 대입해도 되는 대신에 슬라이스 1개라는 의미를 전달하기 위해서 슬라이스의 경우는 `슬라이스이름 ...` 으로 대입해야 합니다.
        - 가변인자에 슬라이스를 추가할 때는 `...`을 기재해야 합니다.
          - `...` 을 넣은 의미는 슬라이스를 분해해서 넣으라는 의미
          - `...` 을 넣지 않으면 슬라이스의 슬라이스가 되어버림
        - 리턴은 빈 공간이 있으면 현재 슬라이스가 가리키는 배열뒤에 데이터를 추가해서 동일한 참조를 리턴하지만 빈 공간이 없는 경우는 새로운 공간을 할당받아서 데이터를 추가한 후 그 참조를 리턴합니다.

  - collection: 동일한 데이터의 모임

  - 슬라이스나 배열을 deep copy 해주는 함수
    - `copy(복사본을 받을 배열이나 슬라이스, 복사할 배열이나 슬러이스)`
      - 두 개의 크기가 같으면 전체 복사
      - 앞의 슬라이스가 크면 뒤의 내용만큼 복사하고 나머지 그대로
        ``` go
          copy({1,2,3,4}, {5,6,7,})
          {5,6,7,4}
        ``` 
      - 뒤의 슬라이스가 크면 앞의 크기만큼 복사 
        ``` go
          copy({1,2}, {5,6,7,})
          {5,6}
        ``` 

## 메모리 영역
함수가 호출돼서 함수가 할당받는 메모리 영역(stack): 함수의 수행이 종료되면 자동 소멸
- 정적 메모리 영역
  -  할당받고 수정하는것은 가능하지만 소멸은 안됩니다. 
  -  전역이라고 부르는 경우가 많습니다.
  -  프로그램이 종료될 때 정리됩니다.
-  동적 메모리 영역
   -  동적 메모리 할당을 받은 데이터가 존재하는 영역인데 필요에 따라 해제가 가능합니다.
   -  일반적으로는 가리키는 데이터가 없을 때 해제를 합니다.
   -  a -> 10(In Use : true) 해제하면 10(In Use : false)
   -  해제와 지우는건 다른 개념이다.
   -  할당하는 명령어 `new`
   -  히제하는 명령어는 없음. 자동해제
## 포인터
- 포인터
  - 참조를 저장하기 위한 자료형
  - 다른 데이터의 참조를 저장할 수 있고, 자신이 메모리 영역을 직접 할당받아서 참조를 저장할 수도 있음
  - 동적 메모리 할당 : 프로그램이 시작되서 실행 중에 메모리를 할당 받는 것
  - 동적으로 메모리 할당을 받은 상황에 따라 garbage collection이 메모리 공간을 해제해서 다시 사용하도록 할 수 있습니다.
- 포인터 변수 선언
  - `var 이름 * 가리킬 수 있는 자료형` : 이 경우 현재는 nil 을 가리킵니다.
- 포인터 변수에 대입
  - 다른 데이터의 참조를 대입
  ``` go
  포인터변수 = &값 데이터
  포인터변수 = 참조형데이터
  ```
  - 동적 메모리 할당
  ``` go
  포인터변수 = new(할당받을 자료형)
  ```
- 포인터 변수의 데이터 접근
  - `포인터변수` : 참조(참조에 해당하는 코드가 리턴돼야 하는데 특별한 경우에는 `&데이터`형태로 출력되기도 합니다.)
  - `*포인터변수` : 포인터변수가 가리키는 곳의 데이터
  - `&포인터변수` : 포인터 변수 자체의 참조
  - go에서는 포인터 변수를 가지고 연산을 할 수 없기 때문에 배열의 용도로는 사용할 수 없습니다.
  - 이 역할을 위해 만들어진 것이 `slice`입니다.
  - `slice`가 불법적인 접근을 못하도록 하기 위해서 `slice`내부는 배열에 대한 참조, 데이터 개수, 할당받은 용량으로 구성
- 포인터를 사용하는 이유
  - 서로 다른 영역에서 데이터를 공유하기 위해서
  - 크기가 큰데(구조체) 계속 사용되지 않는 데이터를 동적 메모리 할당을 받아서 사용하기 위해서

## 가비지 컬렉터
``` go
var str string = "Hello"
str = str + "World"
```
- str 에 `"Hello World"`를 넣어야 하기 때문에 기존 `"Hello"`와의 연결을 해제하고 새로운 메모리를 할당받지만 기존 메모리는 해제가 되지 않아 남아있습니다.
- 이 문제를 해결하는 방법이 strings.Builder를 이용하면 문자열을 동적 메모리 영역에 생성 가능
- 적절한 디자인 패턴을 적용 고려 - flyweight 패턴(기존 객체를 재사용)
- 80:20 법칙 : 메모리를 많이 쓰는애가 있는데 걔를 잡아야 효율적으로 메모리 관리가 가능하다
- 슬라이스에 대한 이해를 하고 사용하자 : 실질적 메모리 누수는 여기서 많이 생김
