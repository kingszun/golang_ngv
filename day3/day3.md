# Go Concurrency(동시성)

## Process, Thread, Goroutine
- Process : 실행중인 프로그램
- Thread : 프로세스 보다는 가벼운 작은 실행 단위, 운영체제(커널) 수준에서 관리
  - 실행 중에 다른 Thread로 제어권을 넘길 수 있음
- Goroutine: Thread 보다 가벼운 실행 단위, Go Scheduler가 관리
  - 실행중에 다른 Goroutine으로 제어권을 넘길 수 있음
  - Process > Thread > Goroutine 순으로 무거움
  - Thread보다 가볍기 때문에 Context Switching으로 인한 부담이 적어 동시에 많은 개수의 Goroutine을 수행   
    - Context Switching: 작업을 수행하는 도중에 다른 작업으로 제어권을 넘기려면 현재 작업의 내용을 저장하고 새로 수행할 작업의 내용을 가져와야함
  - Goroutine은 Demon Thread 형태로 동작함 - 다른 작업이 없으면 자동 종료
    - main함수도 실제로는 Goroutine으로 동작 - main도 다른 작업이 없으면 자동 종료
    - 이 원리 때문에 goroutine을 학습할 때 키보드 입력을 받는 `fmt.Scanln`이나 `time.Sleep`함수를 이용해서 고루틴의 수행이 끝날때까지 대기를 시켜 결과를 확인합니다.
    - 다른 책을 보고 공부할때는 `wait`부터 공부하자.

## runtime.GOMAXPROCS()
- `runtime.NumCPU()`: 현재 컴퓨터의 논리적인 CPU개수(Core 개수) 리턴
- `runtime.GOMAXPROCS(n int)`: 동시에 수행 가능한 Thread의 개수 설정합니다.
  - 기본값은 `runtime.NumCPU()` 와 같음
  - 숫자가 넘어가면 효율이 떨어짐
  - 숫자가 적으면 동시성 효율이 떨어짐

## Goroutine 수행
- 함수 호출 구문 앞에 `go`를 추가하면 됩니다.
- `goroutine`을 사용하면 수백개를 돌려도 `Thread`보다 훨신 동시성이 빠름

## Goroutine 사이의 통신
- 공유메모리(전역변수)를 사용해도 되지만 채널 사용을 권장합니다. - `go`는 공유메모리 사용을 권장하지 않음
- `channel`: `goroutine`끼리 통신을 할 수 있도록 해주는 개념
  - 종류는 `동기 채널`과 `비동기 채널` 2가지가 있음
  - `동기 채널`: 채널에 기록하는 로직이 수행될 때 까지 채널의 데이터를 읽는 것을 블럭
    - 기록을 했는데 읽지 않으면 다시 기록하는것은 안됨
  - `비동기 채널`: 채널에 기록하는 로직이 수행될 때 블럭하지 않고 기록하고 있는 중에도 데이터를 읽어내는 채널

### 동기 채널
- 생성

  ``` go
  var 이름 chan 전달할데이터타입 = make(chan 전달할데이터 타입)
  ```
  ``` go
  이름 := make(chan 전달할데이터 타입)
  ```
- 채널에 기록

  ``` go
  채널이름 <- 데이터
  ```
- 채널에서 읽어오기

  ``` go
  변수 또는 생략 <- 데이터
  ```
- 채널의 데이터를 읽을 때 `range`를 사용할 수 있는데 `range`를 사용하면 `close`될 때까지 계속 데이터를 읽어냅니다.
  - 하나하나 읽는것 보다 좀더 효율적입니다.

### 채널 닫기
``` go
close(채널)
```
- 닫힌 채널에 기록을 하면 `panic`
- 닫힌 채널에서 데이터를 읽으면 zero value가 리턴

### 함수의 매개변수로 채널 사용
- 이 경우는 채널의 용도를 명시하는 것이 가능
  - 채널의 데이터 자료형 앞에 `<-`를 추가하면 쓰기 전용
    ``` go 
    ch chan <- int
    ```
  - 채널의 이름 앞에 `<-`를 추가하면 읽기 전용

    ``` go
    <- ch chan int
    ```

### select
- 여러 채널(시그널)로 데이터를 

### time.Tick 과 time.After
- `time.Tick`은 주기적으로 시그널을 만들어 냅니다.
- `time.After`는 일정 시간 후에 시그널을 만들어 냅니다.
- 고루틴의 데이터 전송을 기다리다가 일정 시간 동안 반응이 없으면 종료하고자 할 때 사용

### 비동기 채널
- 버퍼를 이용해서 비동기적으로 동작하는 채널을 생성할 때 사용
  - 버퍼에 기록하는 동작은 버퍼의 데이터를 읽는 동작과 무관하게 수행되고 버퍼의 데이터를 읽는 동작은 버퍼에 데이터가 전부 기록될 때 수행합니다.
  - 버퍼에 데이터가 없으면 대기
- 생성

  ``` go
  make(chan 자료형, 버퍼의 크기)
  ```
|||
|:--:|:--|
|동기| 채널 기록 -> 채널 읽기 -> 채널 기록 -> 채널 읽기|
|비동기| 채널에 기록과 읽기가 독립적으로 수행<br>채널에 기록을 할 때 버퍼가 가득 차 있으면 기록을 못함<br>채널에 데이터가 없다면 읽기 작업은 블럭|
|||

## sync 패키지
### WaitGroup
- 수행중인 고 루틴 개수를 관리하는 구조체
- 구조체
  - 수행중인 고루틴의 개수를 추가하는 함수

    ``` go
    Add(고루틴 개수)
    ```
  - 수행 중인 고루틴의 개수를 1 감소시키는 함수

    ``` go
    Done()
    ```
  - 대기하고 있다가 수행 중인 고루틴의 개수가 0이되면 대기가 해제되고 다음 작업을 수행

    ``` go
    wait()
    ```

### goroutine
- Mutual Exclusion(상호 배제): 하나의 작업이 사용 중인 데이터는 다른 작업이 수정하면 안된다.
- 생산자와 소비자 패턴: 하나의 작업이 공유 자원을 생성하고 다른 작업은 공유 자원을 소비하는 형태
- `dead lock`: 결코 발생할 수 없는 사건을 무한정 기다리는 것
  - `go routine`안에 다른 `go routine`을 호출하는 작업을 하지 않으면 어느 정도 예방 됨

### 상호 배제 : Mutex, RWMutex
- Lock을 이용해서 공유 자원을 사용 중 일 때 다른 작업이 공유 자원을 사용하지 못하도록 하는 구조체
- `Mutex`: `Lock`을 설정하면 읽기와 쓰기 작업 모두 할 수 없게 합니다.
- `RWMutex`: `Lock`의 종류를 2개로 만들어서 읽기와 쓰기 모두 못하도록 할 수 있고 쓰기만 못하도록 할 수 도 있습니다.

### cond
- wait를 호출하면 시그널을 보내줄 때 까지 대기
- 생성자는 하나의 `goroutine`이나 대기 중인 모든 `goroutine`을 깨울 수 있는 `Signal`과 `Broadcast`를 수행

### Atomic 연산 지원
- 덧셈이나 뺄샘 그리고 데이터를 읽고 쓰는 작업을 원자적(중간에 다른작업이 끼어들지 않고 한번에)으로 수행할 수 있도록 합니다.

### Once
- 한번만 수행

## context 패키지
- `goroutine`의 작업 종료
- `goroutine`이 일정시간동안 작업을 수행하도록 함
- `goroutine`이 값을 전달하는 작업을 수행할 수 있도록 해주는 패키지
- `Context`라는 인터페이스 존재
  - 이 인터페이스는 `context.WithCancle`, `context.WithTimeout` 같은 함수를 호출하면 메서드를 구현한 인스턴스가 리턴 이때 함수도 같이 리턴되는데 이함수를 호출하면 `context`에 `Done`

# Package
## 모듈 생성 및 외부 라이브러리 다운로드
### 모듈
- 하나의 애플리케이션이나 라이브러리에 해당
- 이전에는 패키지가 가장 큰 개념이었지만 이제는 모듈이 가장 큰 개념

## 모듈 생성
- `go.mod`라는 파일 생성: 모듈에 대한 정보와 외부 라이브러리에 대한 정보가 기재
``` bash
go mod init 모듈이름
```

## 외부 모듈 또는 패키지 다운로드
- 모듈이 생성 안된 경우
``` bash
go get 외부패키지 이름
```
- 모듈이 생성된 경우
  - `go.sum` 파일 생성
    - 외부 라이브러리에 대한 정보가 기재
``` bash
go mod tidy
```

## 바이너리 파일 생성
- 모듈 이름으로 바이너리파일 생성
``` bash
go build
```
- 바이너리 파일의 이름을 직접 설정
``` bash
go build -o 바이너리파일이름
```
- 소스파일과 동일한 이름의 바이너리 파일 생성
``` bash
go build 소스파일
```

``` bash
go mod init 패키지이름
```

## 패키지
- 모듈생성(패키지 생성)
  ``` bash
  go mod init github.com/kingszun/package/calc
  ```

- 내부에 만든 모듈을 사용하기 위해서 모듈의 경로를 상대경로로 변경

  ``` bash
  go mod init
  go mod edit -replace github.com/kingszun/package/calc=../calc
  go mod tidy # 다른 모듈을 전부 가져오는 명령
  go run main.go
  ```

## init 함수
- 패키지 안에 `init`함수가 있으면 이 함수는 `import`할 때 자동 호출됩니다.
- `init`을 만들 때는 매개변수가 없고 리턴이 없는 형태로 만들어야 합니다.
- 하나의 파일에 여러개를 만들어도 되는데 여러개를 만들면 순서대로 호출됩니다.
- `init`은 `main`함수보다 먼저 호출됩니다.
- 패키지에 만든 전역 변수의 초기화 작업에 주로 이용됩니다.

# test
## go function test
- 테스트 명령

  ``` go
  go test
  ```
- 규약
  - 테스트 파일의 이름은 `_test.go`로 끝나야 합니다.
  - `testing` 패키지를 `import`
  - 테스트 함수의 이름은 `Test`로 시작해야 하고 매개변수는 `*testing.T`타입 1개 이어야 합니다.
- 함수의 매개변수를 이용해서 테스트에 실패했을 때 메세지를 만들 수 있습니다.

``` go
매개변수.Errorf(메시지)
```
## 코드 커버리지 테스트
- 테스트 함수를 통해서 실행되지 않은 코드 블럭이나 코드 구문을 찾고자 하는 테스트

  ``` bash
  go test -cover
  ```
- 보고서로 만들 수 있음

  ``` bash
  go test -coverprofile=coverage.out
  ```
- 도달할 수 없는 라인도 찾을 수 있습니다.

  ``` bash
  go vet 파일경로
  ```

## 벤치마크 테스트
- 규약
  - 테스트 파일의 이름은 `_test.go`로 끝나야 합니다.
  - `testing`패키지를 `import`
  - 테스트 함수의 이름은 `Benchmark`로 시작해야 하고 매개변수는 `testing.B` 타입 1개 이어야합니다.
- 기본적으로 1초동안 수행
  - 몇번 수행했는지 와 평균적으로 얼마가 걸리는지를 출력해줍니다.

- 속도테스트

  ``` bash
  go test -bench .
  ```
- 메모리 할당까지 확인

  ``` bash
  go test -bench=. -benchmem
  ```
  - 정수, 실수, 복소수, bool, byte, rune, 구조체, 배열 
    - 크기 설정이 불가능
  - `slice`와 `map`은 참조형
    - 크기를 설정해서 생성하는 것이 가능
    - `slice`
      ``` go
      make([] 슬라이스의 자료형, 데이터 개수, 용량)
      ```
    - `map`
      ``` go
      make(map[키의자료형]값의 자료형, 용량)
      ```
