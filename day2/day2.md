# 함수(function)

## 함수

- 별도의 메모리 공간을 할당받아 수행할 수 있는 코드 블럭
- 함수와 메서드의 차이는 리시버의 여부 차이
- 함수는 리시버가 없어서 아무 곳에서나 사용 가능하지만 메서드는 리시버가 있어서 리시버를 통해서만 사용이 가능
- 앞에 `?.` 이 있으면 메서드이고 없으면 함수
- 요즘은 거의 메서드와 함수 둘다 지원
  - 메서드
    - 메서드는 리시버가 있어서 사용제한이 가능
    - 메서드를 사용하려면 무언갈 꼭 만들어야함
    - 매서드를 사용하려면 꼭 객체를 만들어야함
  - 함수
    - 함수는 아무곳에서나 접근 가능함

## 함수의 정의와 호출

1. 함수 정의

    ```
    func 이름(매개변수이름 자료형, ...) 리턴타입
    {
        함수 내용
        return 데이터
    }
    ```

    - 매개변수가 없으면()
    - 리턴되는 데이터가 없으면 리턴 타입은 생략 가능
    - `func (매개변수이름 자료형, ...)`을 함수의 signature(자료형)라고 합니다.

2. 함수 호출(실행)
   - `함수이름(매개변수 대입)`
   - go는 ()로 감싸서 여러개의 데이터 리턴이 가능
     - 이때 리턴되는 값을 받을 때는 여러 개의 변수로 받아도 되고
     - 하나의 변수로 받으면 첫번째 데이터만 대입하고 나머지는 사용하지 않음
     - 앞의 데이터를 생략하고자 하는 경우는 `_`로 설정해야합니다.
   - go에서는 2개를 리턴하는 경우가 2가지 인데
     - 배열, 슬라이스, map의 경우 range로 호출하면 `index`와 `value`가 리턴
     - 그 이외에 예외가 발생할 가능성이 있는 함수들은 `정상수행 결과`와 `예외 내용`을 error타입으로 리턴해 예외 발생을 줄여줍니다.
       - `try ~ catch`와 같은 예외 처리 구문을 사용하지 않아도 되도록 해줍니다.
       - `(변수, err)`
         - err 이 nil 이면 정상 수행
         - err 이 nil 이 아니면 정상 수행 실패

## 함수는 일급 객체

- 함수는 사용자 정의 자료형이다.
- 함수 이름은 함수 내용을 저장하고 있는 곳의 참조
- 함수도 변수로 대입이 가능하다
- 함수 안에 함수를 만들 수 있다.
- 함수를 리턴할 수 있다.
- 익명 함수가 가능하다.
- closure: 함수 내부의 데이터를 함수 외부에서 변경 할 수 있다.
- c에서는 함수포인터를 이용해 다형성을 구현 가능하다.

- 익명함수(anonymous function)
  - 함수의 이름이 없는 함수
  - 생성방법

    ```
    func(매개변수 나열) 리턴 타입{
        내용
    }
    ```

  - 생성과 동시에 수행

    ``` func(매개변수 나열) 리턴 타입{
        내용
    }(매개변수 대입)
    ```

    - 메모리 절약을 위해 사용
- 호출하는 함수와 호출 당하는 함수
  - 호출하는 함수의 데이터를 호출 당하는 함수에서 변경할 때는 참조를 호출당하는 함수에 넘겨주면 됩니다.
  - 호출 당하는 함수의 데이터를 호출하는 함수에서 변경을 할 수 있는가?
    - 기본적으로 호출하는 함수의 수명이 더 길고 함수 내의 데이터는 함수 내에서만 유효하기 때문에 힘듭니다.

- `defer` : 지연호출
  - 함수를 호출하는 구문 앞에 `defer`를 추가하면 이 함수를 호출하는 것은 가장 마지막에 무조건 수행됩니다.
  - 다른 언어의 `finally`와 유사한 역할을 하는데 대신 마지막에 호출된다는 점이 다른점입니다.
  - 외부 resource(파일, 네트워크, 데이터베이스, 하드웨어 추상화 자원)를 사용한 경우 resource 사용이 끝나면 반드시 닫아야한다.
    - TCP 통신

        ```
        송신 ->
            <- 수신
        ```

    - 이렇게되면 열자마자 닫는게 됨

        ```
            open()
            close()
        ```

    - `defer`를 통해 지연시킬 수 있음

        ```
        open()
        defer close() // defer가 붙으면 무조건 수행하고 맨 마지막에 수행
        ```

    - `defer` 가 여러개 사용되면 `defer`는 함수 내부에서 사용하므로 stack(last in first out) 에 저장.
      - `defer`는 사용한 역순으로 호출됩니다.
    - go에서 예외가 발생하더라도 계속 수행하고자 하면 `defer`함수에 복구(recover)를 수행해야 합니다.
    - 외부 자원을 사용하는 문장 다음에 외부 자원을 닫는 함수 앞에는 `defer`를 반드시 추가합니다.
    - panic이 발생했을 때 프로그램을 중단하지 않고 작업을 수행하도록 할 때 defer 함수 안에서 recover()를 호출하면 됩니다.
    - 이 경우에는 panic이 발생할 가능상이 있는 구문보다 먼저 호출되어야 합니다.

# 객체지향 프로그래밍(OOP)

- `Go`에는 클래스가 없습니다.
- `Go`는 구조체 메서드 인터페이스 등을 이용해서 객체 지향 프로그래밍의 개념을 전부 구현할 수 있습니다.

## 구조체(struct)

- 여러 필드(변수)를 묶어서 하나로 표현하는 사용자 정의 자료형

### 구조체 선언

``` go
type 이름 struct{
    필드이름 자료형
    필드이름 자료형
    ...
}
```

- 구조체 안에 필드를 만들 때 시스템 워드의 크기보다 작은 데이터가 2개 이상 존재하는 경우 모아서 선언하는 것이 메모리를 절약합니다.
- 메모리 할당을 할 때 워드의 크기가 최소 단위이기 때문
  - 이렇게 만들면 word(64)x3 비트 할당

    ``` go
    type person struct{
        age int8
        name string
        weight int16
    }
    ```

  - 이렇게 만들면 word(64)x2 비트 할당

    ``` go
    type person struct{
        age int8
        weight int16
        name string
    }
    ```

- `type`은 자료형을 만들 때 사용하는 예약어인데 struct 나 interface를 만들 때 사용할 수 있고 기존 자료형과 구조는 같지만 새로운 이름을 만들고자 할 때도 사용
  - `type INTEGER int` : int라는 자료형과 동일한 `INTEGER`라는 자료형을 생성
  - 그러나 `go`는 다른 자료형이라고 간주함

## 구조체 인스턴스 생성

- zero value로 초기화된 구조체 인스턴스 생성

    ``` go
    var 변수이름 구조체이름 
    ```

- zero value로 초기화된 구조체 인스턴스 생성하고 참조를 변수에 대입

    ``` go
    var 변수 = new(구조체이름)
    변수 = new(구조체이름)
    ```

- zero value로 초기화된 구조체 인스턴스 생성

    ``` go
    구조체이름{}
    ```

- 필드에 순서대로 값을 대입한 구조체 인스턴스 생성

    ``` go
    구조체이름{값을 나열}
    ```

- 필드에 값을 대입한 구조체 인스턴스 생성(생략된 필드는 zero value)

    ``` go
    구조체이름{필드이름:값, 필드이름:값, ...}
    ```
- 구조체 인스턴스는 되도록이면 동적 메모리 할당을 받아서 사용하는 것을 권장합니다.
- 생성자 함수(클래스의 객체를 만들기 위한 함수 - 클래스 안에 자동으로 생성) 와 유사한 방식 
  - `Go` 는 생성자가 존재하지 않음
  - 별도의 함수를 만들어서 생성자처럼 사용하는데 이름은 new로 시작하고 참조를 리턴하는 형태로 만드는 것이 일반적 
  -  만들어서 사용하는 이유는 외부에서 데이터를 받아서 생성하고자 하는 것 과 인간 턴스가 만들어질 때 특수한 작업을 하기 위 해서 입니다.

## method
- 리시버(함수를 호출하는 대상)가 존재하는 함수
- 선언
    ``` go
    func (구조체이름 구조체타입) 메서드이름 (매개변수) 리턴타입{
        매서드 내용
    }
    ```
- 구조체이름은 호출하는 대상 인스턴스
- 인스턴스를 내부에서 사용하지 않을 거라면 구조체 일므 대신에 `_`를 해야 합니다.
- 구조체 이름은 다른 언어의 this나 self역할
- 구조체 타입을 포인터로 설정할 수도 있는 이 경우에는 구조체이름을 통해서 호출하는 구조체의 필드를 변경할 수 있고 포인터가 아니면 변경할 수 없습니다.
- 거의 대부분 포인터로 봐야 합니다.
- 호출
    ``` go
    구조체인스턴스.메서드(매개변수 나열)
    ```
- `go`에서는 오버로딩이 존재하지 않음

## 접근 지정자
- `go`에서는 구조체 안의 필드 이름이나 메서드 이름이 대문자로 시작하면 다른 패키지에서 사용이 가능하지만 소문자로 시작하면 현재 패키지에서만 사용 가능합니다.

    ``` go
    name, setName // 현재 패키지에서만 사용 가능
    name, SetName // 모든 패키지에서 사용 가능
    ```

## has a(포함) 와 is a(상속)
- `has a`관계는 구조체 선언 안에 다른 구조체의 인스턴트를 만들어 주면 됩니다.

    ``` go
    type tiny struct{
        num int
        name string
    }
    type huge struct{
        t tiny // t.num과 t.name이 존재
        num init
        name string
    }

    h := new(huge)
    // h.num, h.name, h.t.num, h.t.name 존재
    // 구조체 안에 구조체를 만들어서 has a 관계를 만들어줍니다.
    ```
- `is a`를 만들고자 하는 경우는 구조체 선언 안에 구조체 이름만 추가하면 됩니다.

    ``` go
    type super struct{
        num int
        name string
    }

    type sub struct{
        super // num과 name 필드가 생성됨
        // num과 name이 존재하기 때문에 같은 이름의 필드를 생성할 수 없음
        score int
        //super 구조체는 num과 namedmf 가지지만 sub구조체는 num, name, score를 갖게됩니다.
    }

    ```

## overriding과 유사한 개념은 존재
- `overriding`: 상위 클래스에 존재하는 메서드를 하위 클래스에서 다시 만드는 것
  - 목적은 기능 확장
  - 자바에서는 인터페이스의 메서드를 만드는 것도 overriding 이라고 하는데 최근에 이 경우는 implementation으로 구분합니다.
  - 메서드도 내려받기 때문에 상위 구조체에 존재하는 모든 메서드를 하위 구조체에서 사용할 수 있는데, 동일한 이름의 메서드를 다시 만들 수 있습니다.
    - 이 경우는 상위 구조체의 이름으로 호출하면 새로 만들어진 메서드가 호출되고, 상위 구조체의 메서드를 호출하고자 하는 경우에는 `상위 구조체이름.메서드()`로 호출 가능

        ``` go
        // 얘는 이상함
        overriding 메서드이름(){
            내용
        }
        // overriding은 기능의 확장이기 때문에 상위 클래스에 존재하는 메서드를 포함시켜야함
        // 
        overriding 메서드이름(){
            super.메서드이름()
            내용
        }
        overriding 메서드이름(){
            내용
            super.메서드이름()
        }
        ```
# interface
- 메서드의 원형만 가진 개채
- 인터페이스는 메모리 할당을 받을 수 없습니다.
- 인스턴스 생성을 할 수 없습니다.
- 변수는 선언이 가능한데 인터페이스의 변수에는 인터페이스가 가진 모든 메서드를 소유한 구조체의 인스턴스만 대입이 가능합니다.
- `go`에서는 자료형이 일치해야지만 대입이 가능한데 유일한 예외는 인터페이스 변수에는 인터페이스의 메서드를 구현한 구조체의 인스턴스를 대입할 수 있습니다.
  - 인터페이스 변수에 대입된 인스턴스는 인터페이스의 메서드를 가지고 있다고 확신할 수 있습니다.
  - 인터페이스라는 말 대신에 `Protocol`이라고도 합니다.
- 인터페이스 활용을 권장하는데 템플릿 메서드 패턴 적용을 권장하고, 인스턴스들 사이의 약한 결합 관계를 위해서 그리고 다형성 구현을 위해서 사용됩니다.
- 빈 인터페이스는 메서드가 없는 인터페이스인데, 이 인터페이스를 이용하면 모든 자료형의 데이터를 받을 수 있습니다.
  - 대신 사용 할 때는 원래의 자료형으로 변환해서 사용해야 합니다.

# Go에서의 에러 핸들링
## error 인터페이스
- 에러 조건 과 에러메세지를 표현하는 타입
- 참조형으로 생성이 되는데 변수를 만들면 기본값은 nil
- 이 인터페이스에는 Error() 메서드가 선언되어 있는데, 이 메서드는 에러의 내용을 문자열로 리턴하는 메서드로 출력하는 함수에 error변수를 대입하면 자동 호출이 됩니다.
- `fmt.Println(error.Error())`대신에 `fmt.Println(error)`를 사용해도 됩니다.
- `go`에서 제공되는 함수나 메서드 중에서 error를 리턴하는 경우에는 이 리턴값을 확인해서 nil 이면 에러가 없는 것이고, nil이 아니면 에러가 있는 것이므로 적절하게 분기문을 사용해서 처리하면 됩니다.
- 직접 에러를 만들어서 리턴하고자 하는 경우에는 `errors.New(메세지)`를 리턴하거나 `fmt.Error*`함수를 이용해서 메세지를 만들어서 리턴하면 됩니다.

## panic
- `go`에서는 `exception(예외)`라는 단어 대신에 `panic`이라는 용어를 사용합니다.
  - exception: 문법상으로는 문제가 없어서 실행은 되는데 실행 중 잘못된 상황이 발생되서 프로그램이 중단되는 현상
- `panic`이 발생하면 함수 호출 순서를 역순으로 출력합니다.(stack trace라고도 함)
- `panic`이 발생해도 프로그램을 계속 수행하도록 하고자 한다면 `defer`이용해서 호출하는 함수에서 `recover()`를 호출하면 되는데 `defer`를 호출하는 구문이 `panic`이 발생하기 이전에 호출되어야 합니다.
- 개발자가 강제로 `panic`을 발생시키고자 한다면 `panic(메세지)`를 호출하면 됩니다.
- `recover`함수의 리턴값은 `panic`이 발생할 때 대입된 메세지 입니다.

# Map
- `key`와 `value`를 쌍으로 저장하는 자료구조로 참조형입니다.
- 변수 선언 - 현재는 nil

    ``` go
    var 이름 map[key의 자료형]val의 자료형
    ```
- 데이터를 가지고 생성

    ``` go
    이름 := {key:value, key:value..}
    ```
- 비어있는 `map`을 생성하고 싶을 때는

    ``` go
    이름 := make(map[키의 자료형]val의 자로형)
    ```
- 데이터 1개 접근

    ``` go
    이름[key] // key에 해당하는 데이터를 찾아오는데 2개가 리턴됩니다.
    // 실제 값, 키의 존재여부 를 가져옵니다.
    ```
  - 존재하지 않는 `key`를 대입하면 앞의 데이터는 기본값이고 뒤의 데이터는 `false`

- 데이터 추가 및 갱신

    ``` go
    이름[key] = 값
    ```
  - `key`가 존재하지 않으면 추가이고 존재하면 갱신

- 데이터 삭제

    ``` go
    delete(이름, key)
    ```
- 데이터 순회

    ``` go
    for k, v := range 이름{
    }
    ```
  - `k`는 `key`이고 `v`는 `value`입니다.

- 데이터 개수

    ```go
    len(이름)
    ```
- `map`의 `key`는 해싱을 이용해서 생성되고 접근합니다.

    ||데이터 추가 및 삭제|데이터조회|
    |------|---|---|
    |배열이나 슬라이스|O(N)|O(1)|
    |linked list|O(1)|O(N)|
    |Map|O(1)|O(1)|
- `map`의 단점 : 메모리 낭비가 심함
  - 하나의 `key`에 하나의 데이터만 저장
map